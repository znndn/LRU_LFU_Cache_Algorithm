
### 原因一 (致命崩溃)：非法内存访问 - 解引用 `nullptr`

这是导致你崩溃**最主要、最频繁**的原因。它以多种形式出现在你代码的几乎每一个函数中。

* **问题简述：**
  你试图在 `FreqToList` 这个 `map` 中获取一个 `FreqList*` 指针，但你获取到的其实是一个 `nullptr`。在下一行，你立刻尝试使用这个空指针（例如 `nullptr->addNodeToCurrTail(...)`），导致程序崩溃。

* **它为什么会发生？(关键)**
  这归咎于 `std::unordered_map` 的 `operator[]`（方括号）的特性：
    1.  当你写 `FreqToList[key]` 时，`map` 会去查找 `key`。
    2.  如果 `key` **不存在**，`map` 会**自动为你创建一个新条目**。
    3.  这个新条目的值是该值类型的“默认值”。
    4.  对于 `FreqList<Key,Value>*` 这种指针类型，**默认值就是 `nullptr`**。

* **崩溃发生点：**
    1.  **`DeleteOldNode` 函数 (最开始的崩溃):**
        * **代码:** `auto list = FreqToList[minFrequency];`
        * **场景:** `minFrequency` 变量是 `5`，但 `FreqToList` 中没有键为 `5` 的列表。
        * **结果:** `list` 被赋值为 `nullptr`。下一行 `list->getCurrFirstNode()` 导致崩溃。

    2.  **`NodeFreqUpgrade` 函数 (高频崩溃):**
        * **代码:** `FreqToList[node->NodeFrequency]->removeNodeFromCurrList(node);`
        * **场景:** 节点 `node` 的旧频率是 `5`。这个列表可能已经被清空并删除了。
        * **结果:** `FreqToList[5]` 返回 `nullptr`。 `nullptr->removeNodeFromCurrList(...)` 导致崩溃。

    3.  **`get` 和 `put` 函数 (清理逻辑崩溃):**
        * **代码:** `if (FreqToList[OldFrequency]->isEmpty()) ...`
        * **场景:** 同上，`FreqToList[OldFrequency]` 返回 `nullptr`。
        * **结果:** `nullptr->isEmpty()` 导致崩溃。

    4.  **`AddNodeToNewFrequencyList` 函数 (隐藏最深的“毒丸”崩溃):**
        * **代码:** `else { FreqToList[node->NodeFrequency]->addNodeToCurrTail(node); }`
        * **场景:** 这是一个最隐蔽的bug。代码先检查 `FreqToList.contains(key)`，发现**存在**。但是，这个 `key` 之所以存在，恰恰是因为在**之前**的某个地方（比如 `DeleteOldNode`）错误地使用了 `operator[]`，导致一个 `(key, nullptr)` 的“毒丸”条目被插入了。
        * **结果:** `contains(key)` 返回 `true`，但 `FreqToList[key]` 依然返回 `nullptr`。 `nullptr->addNodeToCurrTail(...)` 导致崩溃。

---

### 原因二 (隐蔽泄露)：内存泄漏

* **问题简述：**
  你使用 `new FreqList(...)` 创建了对象，但在它不再需要时（例如，当一个列表变空时），你没有 `delete` 它。你只是从 `map` 中 `erase` 了这个键值对。

* **它为什么会发生？**
  `std::unordered_map::erase(key)` 只会销毁 `map` 中的条目（即那个 `FreqList*` 指针本身），但它**不会** `delete` 指针所指向的内存。你必须手动 `delete`。

* **泄露发生点：**
    1.  **`get` 和 `put` 函数 (清理逻辑):**
        * **代码 (修复前):** `if (FreqToList[OldFrequency]->isEmpty()) { FreqToList.erase(OldFrequency); ... }`
        * **结果:** 你从 `map` 中删除了键 `OldFrequency`，但对应的 `FreqList` 对象永远丢失在了内存中，无法被释放，造成内存泄漏。

    2.  **`ReduceAllNodeFrequency` 函数 (衰减逻辑):**
        * **代码 (修复前):** 在将所有节点移出旧列表后，你没有添加逻辑去 `delete` 那些现在已经变空的旧列表。
        * **结果:** 大量的空 `FreqList` 对象残留在 `map` 中，占用内存。

---

### 原因三 (高难崩溃)：非法内存访问 - 使用已释放内存 (Use-After-Free)

这是你调低阈值时遇到的最复杂的bug。

* **问题简述：**
  一个 `FreqList` 列表被 `delete` 释放了，但程序中仍然有一个节点（`Node`）在引用它。当程序下一次尝试访问这个节点时，它访问了非法内存，导致崩溃。

* **它为什么会发生？**
  这是在 `ReduceAllNodeFrequency`（“aging”函数）中发生的逻辑竞态：
    1.  **标记**：`NodeA` 从 `FreqList[10]` 移出，`FreqList[10]` 变空，被**标记为“待删除”**。
    2.  **重用**：循环继续，`NodeB` 从 `FreqList[15]` 移出，它的新频率“恰好”也是 `10`。它被添加回了 `FreqList[10]`。此时 `FreqList[10]` **不再为空**。
    3.  **删除**：循环结束，清理阶段开始。程序查看“待删除”标记，`delete FreqToList[10];`。
    4.  **崩溃**：`FreqList[10]` 被释放了，但 `NodeB`（它还在 `cache` 中）仍然指向它。当下次 `get(NodeB_key)` 时，程序尝试访问 `NodeB` 的 `prev`/`next` 指针（它们指向刚被释放的内存），导致崩溃。

### 总结：你的 `LRU` 和 `LFU` 的关键对比

* **你的 `LRUAlgorithm.h` (优秀)：**
  你使用了 `std::shared_ptr` 和 `std::weak_ptr` (智能指针)。它们会自动管理内存。当一个 `LRUNode` 不再被 `cache` 和双向链表引用时，它会被自动销毁。你**不需要**写任何 `new` 或 `delete`，因此**完全没有**上述所有内存问题。

* **你的 `LFUAlgorithm.h` (高难度)：**
  你使用了 `FreqList*` (原始指针)。你被迫手动管理 `new` 和 `delete`，这导致了 `nullptr` 崩溃、内存泄漏 和 `Use-After-Free`。

**给你的核心建议：** 作为C++初学者（甚至对于专家也是），请**始终优先使用智能指针**（`std::unique_ptr` 和 `std::shared_ptr`）。你写 `LRU` 的方式才是现代、安全的C++实践。